namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace ns1 = "http://www.w3.org/1999/xhtml"
namespace rng = "http://relaxng.org/ns/structure/1.0"
namespace sch = "http://purl.oclc.org/dsdl/schematron"
default namespace tei = "http://www.tei-c.org/ns/1.0"
namespace teix = "http://www.tei-c.org/ns/Examples"
namespace xi = "http://www.w3.org/2001/XInclude"
namespace xlink = "http://www.w3.org/1999/xlink"

# Schema generated from ODD source 2025-09-04T16:14:56Z. . 
# TEI Edition: P5 VersionÂ 4.10.2. Last updated on 4th September 2025, revision bcfa98f42 
# TEI Edition Location: https://www.tei-c.org/Vault/P5/4.10.2/ 
#

# This template file is freely available and you are hereby authorised to copy, modify, and redistribute it in any way without further reference or permissions. When making such modifications, you are strongly recommended to change the present text to include an accurate statement of the licencing conditions applicable to your modified text.
macro.limitedContent = (text | model.limitedPhrase | model.inter)*
macro.xtext = (text | model.gLike)*
att.cmc.attributes = att.cmc.attribute.generatedBy
att.cmc.attribute.generatedBy =
  
  ## (generated by) categorizes how the content of an element was generated in a CMC environment.
  ## Suggested values include: 1] human; 2] template; 3] system; 4] bot; 5] unspecified
  attribute generatedBy {
    
    ## the content was naturally typed or spoken by a human user
    "human"
    | 
      ## the content was generated after a human user activated a template for its insertion
      "template"
    | 
      ## the content was generated by the system, i.e. the CMC environment
      "system"
    | 
      ## the content was generated by a bot, i.e. a non-human agent, typically one that is not part of the CMC environment itself
      "bot"
    | 
      ## the content was generated by an unknown or unspecified process
      "unspecified"
    | xsd:token { pattern = "[^\p{C}\p{Z}]+" }
  }?
sch:pattern [
  id =
    "isofs-att.cmc-generatedBy-CMC_generatedBy_within_post-constraint-rule-1"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "tei:*[@generatedBy]"
    "\x{a}" ~
    "         "
    sch:assert [
      test = "ancestor-or-self::tei:post"
      "The @generatedBy attribute is for use within a <post> element."
    ]
    "\x{a}" ~
    "      "
  ]
  "\x{a}" ~
  "   "
]
att.datcat.attributes =
  att.datcat.attribute.datcat,
  att.datcat.attribute.valueDatcat,
  att.datcat.attribute.targetDatcat
att.datcat.attribute.datcat =
  [
    a:documentation [
      "provides a pointer to a definition of, and/or general information about, (a) an information container (element or attribute) or (b) a value of an information container (element content or attribute value), by referencing an external taxonomy or ontology. If "
      ns1:code [ "@valueDatcat" ]
      " is present in the immediate context, this attribute takes on role (a), while "
      ns1:code [ "@valueDatcat" ]
      " performs role (b)."
    ]
  ]
  attribute datcat {
    list {
      xsd:anyURI { pattern = "\S+" }+
    }
  }?
att.datcat.attribute.valueDatcat =
  [
    a:documentation [
      "provides a definition of, and/or general information about a value of an information container (element content or attribute value), by reference to an external taxonomy or ontology. Used especially where a contrast with "
      ns1:code [ "@datcat" ]
      " is needed."
    ]
  ]
  attribute valueDatcat {
    list {
      xsd:anyURI { pattern = "\S+" }+
    }
  }?
att.datcat.attribute.targetDatcat =
  [
    a:documentation [
      "provides a definition of, and/or general information about, information structure of an object referenced or modeled by the containing element, by reference to an external taxonomy or ontology. This attribute has the characteristics of the "
      ns1:code [ "@datcat" ]
      " attribute, except that it addresses not its containing element, but an object that is being referenced or modeled by its containing element."
    ]
  ]
  attribute targetDatcat {
    list {
      xsd:anyURI { pattern = "\S+" }+
    }
  }?
att.global.rendition.attributes =
  att.global.rendition.attribute.rend,
  att.global.rendition.attribute.style,
  att.global.rendition.attribute.rendition
att.global.rendition.attribute.rend =
  
  ## (rendition) indicates how the element in question was rendered or presented in the source text.
  attribute rend {
    list {
      xsd:token { pattern = "[^\p{C}\p{Z}]+" }+
    }
  }?
att.global.rendition.attribute.style =
  
  ## contains an expression in some formal style definition language which defines the rendering or presentation used for this element in the source text.
  attribute style { xsd:string }?
att.global.rendition.attribute.rendition =
  
  ## points to a description of the rendering or presentation used for this element in the source text.
  attribute rendition {
    list {
      xsd:anyURI { pattern = "\S+" }+
    }
  }?
att.global.responsibility.attributes =
  att.global.responsibility.attribute.cert,
  att.global.responsibility.attribute.resp
att.global.responsibility.attribute.cert =
  
  ## (certainty) signifies the degree of certainty associated with the intervention or interpretation.
  attribute cert {
    xsd:double { minInclusive = "0" maxInclusive = "1" }
    | (
       ##
       "high"
       | 
         ##
         "medium"
       | 
         ##
         "low"
       | 
         ##
         "unknown")
  }?
att.global.responsibility.attribute.resp =
  
  ## (responsible party) indicates the agency responsible for the intervention or interpretation, for example an editor or transcriber.
  attribute resp {
    list {
      xsd:anyURI { pattern = "\S+" }+
    }
  }?
att.global.source.attributes = att.global.source.attribute.source
att.global.source.attribute.source =
  
  ## specifies the source from which some aspect of this element is drawn.
  attribute source {
    list {
      xsd:anyURI { pattern = "\S+" }+
    }
  }?
sch:pattern [
  id =
    "isofs-att.global.source-source-only_1_ODD_source-constraint-rule-2"
  "\x{a}" ~
  "      "
  sch:rule [
    context = "tei:*[@source]"
    "\x{a}" ~
    "         "
    sch:let [
      name = "srcs"
      value = "tokenize( normalize-space(@source),' ')"
    ]
    "\x{a}" ~
    "         "
    sch:report [
      test =
        "(   self::tei:classRef                                 | self::tei:dataRef                                 | self::tei:elementRef                                 | self::tei:macroRef                                 | self::tei:moduleRef                                 | self::tei:schemaSpec )                                   and                                   $srcs[2]"
      "\x{a}" ~
      "              When used on a schema description element (like\x{a}" ~
      "              "
      sch:value-of [ select = "name(.)" ]
      "), the @source attribute\x{a}" ~
      "              should have only 1 value. (This one has "
      sch:value-of [ select = "count($srcs)" ]
      ".)\x{a}" ~
      "            "
    ]
    "\x{a}" ~
    "      "
  ]
  "\x{a}" ~
  "   "
]
att.global.attributes =
  att.global.rendition.attributes,
  att.global.responsibility.attributes,
  att.global.source.attributes,
  att.global.attribute.xmlid,
  att.global.attribute.xmllang,
  att.global.attribute.xmlbase
att.global.attribute.xmlid =
  
  ## (identifier) provides a unique identifier for the element bearing the attribute.
  attribute xml:id { xsd:ID }?
att.global.attribute.xmllang =
  [
    a:documentation [
      "(language) indicates the language of the element content using a tag generated according to "
      ns1:a [
        href = "http://www.rfc-editor.org/rfc/bcp/bcp47.txt"
        "BCP 47"
      ]
      "."
    ]
  ]
  attribute xml:lang {
    xsd:language
    | (
       ##
       "")
  }?
att.global.attribute.xmlbase =
  
  ## provides a base URI reference with which applications can resolve relative URI references into absolute URI references.
  attribute xml:base {
    xsd:anyURI { pattern = "\S+" }
  }?
model.nameLike.agent = notAllowed
model.nameLike.agent_alternation = notAllowed
model.nameLike.agent_sequence = empty
model.nameLike.agent_sequenceOptional = empty
model.nameLike.agent_sequenceOptionalRepeatable = empty
model.nameLike.agent_sequenceRepeatable = notAllowed
model.segLike = notAllowed
model.segLike_alternation = notAllowed
model.segLike_sequence = empty
model.segLike_sequenceOptional = empty
model.segLike_sequenceOptionalRepeatable = empty
model.segLike_sequenceRepeatable = notAllowed
model.hiLike = notAllowed
model.hiLike_alternation = notAllowed
model.hiLike_sequence = empty
model.hiLike_sequenceOptional = empty
model.hiLike_sequenceOptionalRepeatable = empty
model.hiLike_sequenceRepeatable = notAllowed
model.emphLike = notAllowed
model.emphLike_alternation = notAllowed
model.emphLike_sequence = empty
model.emphLike_sequenceOptional = empty
model.emphLike_sequenceOptionalRepeatable = empty
model.emphLike_sequenceRepeatable = notAllowed
model.highlighted = model.hiLike | model.emphLike
model.highlighted_alternation =
  model.hiLike_alternation | model.emphLike_alternation
model.highlighted_sequence =
  model.hiLike_sequence, model.emphLike_sequence
model.highlighted_sequenceOptional =
  model.hiLike_sequenceOptional?, model.emphLike_sequenceOptional?
model.highlighted_sequenceOptionalRepeatable =
  model.hiLike_sequenceOptionalRepeatable*,
  model.emphLike_sequenceOptionalRepeatable*
model.highlighted_sequenceRepeatable =
  model.hiLike_sequenceRepeatable+, model.emphLike_sequenceRepeatable+
model.dateLike = notAllowed
model.dateLike_alternation = notAllowed
model.dateLike_sequence = empty
model.dateLike_sequenceOptional = empty
model.dateLike_sequenceOptionalRepeatable = empty
model.dateLike_sequenceRepeatable = notAllowed
model.measureLike = notAllowed
model.measureLike_alternation = notAllowed
model.measureLike_sequence = empty
model.measureLike_sequenceOptional = empty
model.measureLike_sequenceOptionalRepeatable = empty
model.measureLike_sequenceRepeatable = notAllowed
model.egLike = notAllowed
model.egLike_alternation = notAllowed
model.egLike_sequence = empty
model.egLike_sequenceOptional = empty
model.egLike_sequenceOptionalRepeatable = empty
model.egLike_sequenceRepeatable = notAllowed
model.graphicLike = notAllowed
model.graphicLike_alternation = notAllowed
model.graphicLike_sequence = empty
model.graphicLike_sequenceOptional = empty
model.graphicLike_sequenceOptionalRepeatable = empty
model.graphicLike_sequenceRepeatable = notAllowed
model.offsetLike = notAllowed
model.offsetLike_alternation = notAllowed
model.offsetLike_sequence = empty
model.offsetLike_sequenceOptional = empty
model.offsetLike_sequenceOptionalRepeatable = empty
model.offsetLike_sequenceRepeatable = notAllowed
model.pPart.msdesc = notAllowed
model.pPart.msdesc_alternation = notAllowed
model.pPart.msdesc_sequence = empty
model.pPart.msdesc_sequenceOptional = empty
model.pPart.msdesc_sequenceOptionalRepeatable = empty
model.pPart.msdesc_sequenceRepeatable = notAllowed
model.pPart.editorial = notAllowed
model.pPart.editorial_alternation = notAllowed
model.pPart.editorial_sequence = empty
model.pPart.editorial_sequenceOptional = empty
model.pPart.editorial_sequenceOptionalRepeatable = empty
model.pPart.editorial_sequenceRepeatable = notAllowed
model.pPart.transcriptional = notAllowed
model.pPart.transcriptional_alternation = notAllowed
model.pPart.transcriptional_sequence = empty
model.pPart.transcriptional_sequenceOptional = empty
model.pPart.transcriptional_sequenceOptionalRepeatable = empty
model.pPart.transcriptional_sequenceRepeatable = notAllowed
model.pPart.edit = model.pPart.editorial | model.pPart.transcriptional
model.pPart.edit_alternation =
  model.pPart.editorial_alternation
  | model.pPart.transcriptional_alternation
model.pPart.edit_sequence =
  model.pPart.editorial_sequence, model.pPart.transcriptional_sequence
model.pPart.edit_sequenceOptional =
  model.pPart.editorial_sequenceOptional?,
  model.pPart.transcriptional_sequenceOptional?
model.pPart.edit_sequenceOptionalRepeatable =
  model.pPart.editorial_sequenceOptionalRepeatable*,
  model.pPart.transcriptional_sequenceOptionalRepeatable*
model.pPart.edit_sequenceRepeatable =
  model.pPart.editorial_sequenceRepeatable+,
  model.pPart.transcriptional_sequenceRepeatable+
model.ptrLike = notAllowed
model.ptrLike_alternation = notAllowed
model.ptrLike_sequence = empty
model.ptrLike_sequenceOptional = empty
model.ptrLike_sequenceOptionalRepeatable = empty
model.ptrLike_sequenceRepeatable = notAllowed
model.lPart = notAllowed
model.lPart_alternation = notAllowed
model.lPart_sequence = empty
model.lPart_sequenceOptional = empty
model.lPart_sequenceOptionalRepeatable = empty
model.lPart_sequenceRepeatable = notAllowed
model.global.meta = fs | fLib | fvLib
model.global.meta_alternation = fs | fLib | fvLib
model.global.meta_sequence = fs, fLib, fvLib
model.global.meta_sequenceOptional = fs?, fLib?, fvLib?
model.global.meta_sequenceOptionalRepeatable = fs*, fLib*, fvLib*
model.global.meta_sequenceRepeatable = fs+, fLib+, fvLib+
model.milestoneLike = notAllowed
model.milestoneLike_alternation = notAllowed
model.milestoneLike_sequence = empty
model.milestoneLike_sequenceOptional = empty
model.milestoneLike_sequenceOptionalRepeatable = empty
model.milestoneLike_sequenceRepeatable = notAllowed
model.gLike = notAllowed
model.oddDecl = notAllowed
model.oddDecl_alternation = notAllowed
model.oddDecl_sequence = empty
model.oddDecl_sequenceOptional = empty
model.oddDecl_sequenceOptionalRepeatable = empty
model.oddDecl_sequenceRepeatable = notAllowed
model.phrase.xml = notAllowed
model.phrase.xml_alternation = notAllowed
model.phrase.xml_sequence = empty
model.phrase.xml_sequenceOptional = empty
model.phrase.xml_sequenceOptionalRepeatable = empty
model.phrase.xml_sequenceRepeatable = notAllowed
model.specDescLike = notAllowed
model.specDescLike_alternation = notAllowed
model.specDescLike_sequence = empty
model.specDescLike_sequenceOptional = empty
model.specDescLike_sequenceOptionalRepeatable = empty
model.specDescLike_sequenceRepeatable = notAllowed
model.biblLike = notAllowed
model.biblLike_alternation = notAllowed
model.biblLike_sequence = empty
model.biblLike_sequenceOptional = empty
model.biblLike_sequenceOptionalRepeatable = empty
model.biblLike_sequenceRepeatable = notAllowed
model.labelLike = notAllowed
model.labelLike_alternation = notAllowed
model.labelLike_sequence = empty
model.labelLike_sequenceOptional = empty
model.labelLike_sequenceOptionalRepeatable = empty
model.labelLike_sequenceRepeatable = notAllowed
model.listLike = notAllowed
model.listLike_alternation = notAllowed
model.listLike_sequence = empty
model.listLike_sequenceOptional = empty
model.listLike_sequenceOptionalRepeatable = empty
model.listLike_sequenceRepeatable = notAllowed
model.noteLike = notAllowed
model.noteLike_alternation = notAllowed
model.noteLike_sequence = empty
model.noteLike_sequenceOptional = empty
model.noteLike_sequenceOptionalRepeatable = empty
model.noteLike_sequenceRepeatable = notAllowed
model.stageLike = notAllowed
model.stageLike_alternation = notAllowed
model.stageLike_sequence = empty
model.stageLike_sequenceOptional = empty
model.stageLike_sequenceOptionalRepeatable = empty
model.stageLike_sequenceRepeatable = notAllowed
model.featureVal.complex = fs | vColl | vNot | vMerge
model.featureVal.single =
  binary | symbol | numeric | \string | vLabel | \default | vAlt
model.global.edit = notAllowed
model.global.edit_alternation = notAllowed
model.global.edit_sequence = empty
model.global.edit_sequenceOptional = empty
model.global.edit_sequenceOptionalRepeatable = empty
model.global.edit_sequenceRepeatable = notAllowed
model.placeNamePart = notAllowed
model.placeNamePart_alternation = notAllowed
model.placeNamePart_sequence = empty
model.placeNamePart_sequenceOptional = empty
model.placeNamePart_sequenceOptionalRepeatable = empty
model.placeNamePart_sequenceRepeatable = notAllowed
model.placeStateLike = model.placeNamePart
model.placeStateLike_alternation = model.placeNamePart_alternation
model.placeStateLike_sequence = model.placeNamePart_sequence
model.placeStateLike_sequenceOptional =
  model.placeNamePart_sequenceOptional?
model.placeStateLike_sequenceOptionalRepeatable =
  model.placeNamePart_sequenceOptionalRepeatable*
model.placeStateLike_sequenceRepeatable =
  model.placeNamePart_sequenceRepeatable+
model.quoteLike = notAllowed
model.quoteLike_alternation = notAllowed
model.quoteLike_sequence = empty
model.quoteLike_sequenceOptional = empty
model.quoteLike_sequenceOptionalRepeatable = empty
model.quoteLike_sequenceRepeatable = notAllowed
model.attributable = model.quoteLike
model.attributable_alternation = model.quoteLike_alternation
model.attributable_sequence = model.quoteLike_sequence
model.attributable_sequenceOptional = model.quoteLike_sequenceOptional?
model.attributable_sequenceOptionalRepeatable =
  model.quoteLike_sequenceOptionalRepeatable*
model.attributable_sequenceRepeatable =
  model.quoteLike_sequenceRepeatable+
model.addressLike = notAllowed
model.addressLike_alternation = notAllowed
model.addressLike_sequence = empty
model.addressLike_sequenceOptional = empty
model.addressLike_sequenceOptionalRepeatable = empty
model.addressLike_sequenceRepeatable = notAllowed
model.nameLike =
  model.nameLike.agent | model.offsetLike | model.placeStateLike
model.nameLike_alternation =
  model.nameLike.agent_alternation
  | model.offsetLike_alternation
  | model.placeStateLike_alternation
model.nameLike_sequence =
  model.nameLike.agent_sequence,
  model.offsetLike_sequence,
  model.placeStateLike_sequence
model.nameLike_sequenceOptional =
  model.nameLike.agent_sequenceOptional?,
  model.offsetLike_sequenceOptional?,
  model.placeStateLike_sequenceOptional?
model.nameLike_sequenceOptionalRepeatable =
  model.nameLike.agent_sequenceOptionalRepeatable*,
  model.offsetLike_sequenceOptionalRepeatable*,
  model.placeStateLike_sequenceOptionalRepeatable*
model.nameLike_sequenceRepeatable =
  model.nameLike.agent_sequenceRepeatable+,
  model.offsetLike_sequenceRepeatable+,
  model.placeStateLike_sequenceRepeatable+
model.featureVal = model.featureVal.complex | model.featureVal.single
model.pPart.data =
  model.dateLike
  | model.measureLike
  | model.addressLike
  | model.nameLike
model.pPart.data_alternation =
  model.dateLike_alternation
  | model.measureLike_alternation
  | model.addressLike_alternation
  | model.nameLike_alternation
model.pPart.data_sequence =
  model.dateLike_sequence,
  model.measureLike_sequence,
  model.addressLike_sequence,
  model.nameLike_sequence
model.pPart.data_sequenceOptional =
  model.dateLike_sequenceOptional?,
  model.measureLike_sequenceOptional?,
  model.addressLike_sequenceOptional?,
  model.nameLike_sequenceOptional?
model.pPart.data_sequenceOptionalRepeatable =
  model.dateLike_sequenceOptionalRepeatable*,
  model.measureLike_sequenceOptionalRepeatable*,
  model.addressLike_sequenceOptionalRepeatable*,
  model.nameLike_sequenceOptionalRepeatable*
model.pPart.data_sequenceRepeatable =
  model.dateLike_sequenceRepeatable+,
  model.measureLike_sequenceRepeatable+,
  model.addressLike_sequenceRepeatable+,
  model.nameLike_sequenceRepeatable+
model.inter =
  model.egLike
  | model.oddDecl
  | model.biblLike
  | model.labelLike
  | model.listLike
  | model.stageLike
  | model.attributable
model.limitedPhrase =
  model.hiLike
  | model.emphLike
  | model.pPart.msdesc
  | model.pPart.editorial
  | model.ptrLike
  | model.phrase.xml
  | model.pPart.data
fsDecl =
  
  ## (feature structure declaration) declares one type of feature structure. [19.11. Feature System Declaration]
  element fsDecl {
    (fsDescr?, fDecl+, fsConstraints?),
    att.global.attributes,
    att.datcat.attributes,
    
    ## gives a name for the type of feature structure being declared.
    attribute type {
      xsd:token { pattern = "[^\p{C}\p{Z}]+" }
    },
    [
      a:documentation [
        "gives the name of one or more typed feature structures from which this type inherits feature specifications and constraints; if this type includes a feature specification with the same name as that of any of those specified by this attribute, or if more than one specification of the same name is inherited, then the set of possible values is defined by unification. Similarly, the set of constraints applicable is derived by combining those specified explicitly within this element with those implied by the "
        ns1:code [ "@baseTypes" ]
        " attribute. When no "
        ns1:code [ "@baseTypes" ]
        " attribute is specified, no feature specification or constraint is inherited."
      ]
    ]
    attribute baseTypes {
      list { xsd:Name+ }
    }?,
    empty
  }
fsDescr =
  
  ## (feature system description (in FSD)) describes in prose what is represented by the type of feature structure declared in the enclosing fsDecl. [19.11. Feature System Declaration]
  element fsDescr { macro.limitedContent, att.global.attributes, empty }
fsdLink =
  
  ## (feature structure declaration link) associates the name of a typed feature structure with a feature structure declaration for it. [19.11. Feature System Declaration]
  element fsdLink {
    empty,
    att.global.attributes,
    [
      a:documentation [
        "identifies the type of feature structure to be documented; this will be the value of the "
        ns1:code [ "@type" ]
        " attribute on at least one feature structure."
      ]
    ]
    attribute type {
      xsd:token { pattern = "[^\p{C}\p{Z}]+" }
    },
    [
      a:documentation [
        "supplies a pointer to a feature structure declaration ("
        ns1:code [ "<fsDecl>" ]
        ") element within the current document or elsewhere."
      ]
    ]
    attribute target {
      xsd:anyURI { pattern = "\S+" }
    },
    empty
  }
fDecl =
  
  ## (feature declaration) declares a single feature, specifying its name, organization, range of allowed values, and optionally its default value. [19.11. Feature System Declaration]
  element fDecl {
    (fDescr?, vRange, vDefault?),
    att.global.attributes,
    att.datcat.attributes,
    [
      a:documentation [
        "a single word which follows the rules defining a legal XML name (see ), indicating the name of the feature being declared; matches the "
        ns1:code [ "@name" ]
        " attribute of "
        ns1:code [ "<f>" ]
        " elements in the text."
      ]
    ]
    attribute name { xsd:Name },
    
    ## indicates whether or not the value of this feature may be present.
    [ a:defaultValue = "true" ] attribute optional { xsd:boolean }?,
    empty
  }
fDescr =
  
  ## (feature description (in FSD)) describes in prose what is represented by the feature being declared and its values. [19.11. Feature System Declaration]
  element fDescr { macro.limitedContent, att.global.attributes, empty }
vRange =
  [
    a:documentation [
      "(value range) defines the range of allowed values for a feature, in the form of an "
      ns1:code [ "<fs>" ]
      ", "
      ns1:code [ "<vAlt>" ]
      ", or primitive value; for the value of an "
      ns1:code [ "<f>" ]
      " to be valid, it must be subsumed by the specified range; if the "
      ns1:code [ "<f>" ]
      " contains multiple values (as sanctioned by the "
      ns1:code [ "@org" ]
      " attribute), then each value must be subsumed by the "
      ns1:code [ "<vRange>" ]
      ". [19.11. Feature System Declaration]"
    ]
  ]
  element vRange { model.featureVal, att.global.attributes, empty }
vDefault =
  [
    a:documentation [
      "(value default) declares the default value to be supplied when a feature structure does not contain an instance of "
      ns1:code [ "<f>" ]
      " for this name; if unconditional, it is specified as one (or, depending on the value of the "
      ns1:code [ "@org" ]
      " attribute of the enclosing "
      ns1:code [ "<fDecl>" ]
      ") more "
      ns1:code [ "<fs>" ]
      " elements or primitive values; if conditional, it is specified as one or more "
      ns1:code [ "<if>" ]
      " elements; if no default is specified, or no condition matches, the value none is assumed. [19.11. Feature System Declaration]"
    ]
  ]
  element vDefault {
    (model.featureVal+ | if+), att.global.attributes, empty
  }
if =
  
  ## defines a conditional default value for a feature; the condition is specified as a feature structure, and is met if it subsumes the feature structure in the text for which a default value is sought. [19.11. Feature System Declaration]
  element if {
    ((fs | f), then, model.featureVal),
    att.global.attributes,
    empty
  }
then =
  [
    a:documentation [
      "separates the condition from the default in an "
      ns1:code [ "<if>" ]
      ", or the antecedent and the consequent in a "
      ns1:code [ "<cond>" ]
      " element. [19.11. Feature System Declaration]"
    ]
  ]
  element then { empty, att.global.attributes, empty }
fsConstraints =
  
  ## (feature-structure constraints) specifies constraints on the content of valid feature structures. [19.11. Feature System Declaration]
  element fsConstraints {
    (cond | bicond)*, att.global.attributes, empty
  }
cond =
  
  ## (conditional feature-structure constraint) defines a conditional feature-structure constraint; the consequent and the antecedent are specified as feature structures or feature-structure collections; the constraint is satisfied if both the antecedent and the consequent subsume a given feature structure, or if the antecedent does not. [19.11. Feature System Declaration]
  element cond {
    ((fs | f), then, (fs | f)),
    att.global.attributes,
    empty
  }
bicond =
  
  ## (bi-conditional feature-structure constraint) defines a biconditional feature-structure constraint; both consequent and antecedent are specified as feature structures or groups of feature structures; the constraint is satisfied if both subsume a given feature structure, or if both do not. [19.11. Feature System Declaration]
  element bicond {
    ((fs | f), iff, (fs | f)),
    att.global.attributes,
    empty
  }
iff =
  [
    a:documentation [
      "(if and only if) separates the condition from the consequence in a "
      ns1:code [ "<bicond>" ]
      " element. [19.11. Feature System Declaration]"
    ]
  ]
  element iff { empty, att.global.attributes, empty }
fs =
  
  ## (feature structure) represents a feature structure, that is, a collection of feature-value pairs organized as a structural unit. [19.2. Elementary Feature Structures and the Binary
  ## Feature Value]
  element fs {
    f*,
    att.global.attributes,
    att.cmc.attributes,
    att.datcat.attributes,
    
    ## specifies the type of the feature structure.
    attribute type {
      xsd:token { pattern = "[^\p{C}\p{Z}]+" }
    }?,
    
    ## (features) references the feature-value specifications making up this feature structure.
    attribute feats {
      list {
        xsd:anyURI { pattern = "\S+" }+
      }
    }?,
    empty
  }
f =
  
  ## (feature) represents a feature value specification, that is, the association of a name with a value of any of several different types. [19.2. Elementary Feature Structures and the Binary
  ## Feature Value]
  element f {
    (text | model.featureVal),
    att.global.attributes,
    att.datcat.attributes,
    
    ## a single word which follows the rules defining a legal XML name (see ), providing a name for the feature.
    attribute name { xsd:Name },
    
    ## (feature value) references any element which can be used to represent the value of a feature.
    attribute fVal {
      xsd:anyURI { pattern = "\S+" }
    }?,
    empty
  }
binary =
  
  ## (binary value) represents the value part of a feature-value specification which can contain either of exactly two possible values. [19.2. Elementary Feature Structures and the Binary
  ## Feature Value]
  element binary {
    empty,
    att.global.attributes,
    att.datcat.attributes,
    
    ## supplies a binary value.
    attribute value { xsd:boolean },
    empty
  }
symbol =
  
  ## (symbolic value) represents the value part of a feature-value specification which contains one of a finite list of symbols. [19.3. Other Atomic Feature Values]
  element symbol {
    empty,
    att.global.attributes,
    att.datcat.attributes,
    
    ## supplies a symbolic value for the feature, one of a finite list that may be specified in a feature declaration.
    attribute value {
      xsd:token { pattern = "[^\p{C}\p{Z}]+" }
    },
    empty
  }
numeric =
  
  ## (numeric value) represents the value part of a feature-value specification which contains a numeric value or range. [19.3. Other Atomic Feature Values]
  element numeric {
    empty,
    att.global.attributes,
    att.datcat.attributes,
    [
      a:documentation [
        "supplies a lower bound for the numeric value represented, and also (if "
        ns1:code [ "@max" ]
        " is not supplied) its upper bound."
      ]
    ]
    attribute value {
      xsd:double
      | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
      | xsd:decimal
    },
    
    ## supplies an upper bound for the numeric value represented.
    attribute max {
      xsd:double
      | xsd:token { pattern = "(\-?[\d]+/\-?[\d]+)" }
      | xsd:decimal
    }?,
    
    ## specifies whether the value represented should be truncated to give an integer value.
    attribute trunc { xsd:boolean }?,
    empty
  }
\string =
  
  ## (string value) represents the value part of a feature-value specification which contains a string. [19.3. Other Atomic Feature Values]
  element string {
    macro.xtext, att.global.attributes, att.datcat.attributes, empty
  }
vLabel =
  
  ## (value label) represents the value part of a feature-value specification which appears at more than one point in a feature structure. [19.6. Re-entrant Feature Structures]
  element vLabel {
    model.featureVal?,
    att.global.attributes,
    
    ## supplies a name identifying the sharing point.
    attribute name {
      xsd:token { pattern = "[^\p{C}\p{Z}]+" }
    },
    empty
  }
vColl =
  
  ## (collection of values) represents the value part of a feature-value specification which contains multiple values organized as a set, bag, or list. [19.7. Collections as Complex Feature Values]
  element vColl {
    (fs | model.featureVal.single | vColl)*,
    att.global.attributes,
    
    ## (organization) indicates organization of given value or values as set, bag or list.
    attribute org {
      
      ## indicates that the given values are organized as a set.
      "set"
      | 
        ## indicates that the given values are organized as a bag (multiset).
        "bag"
      | 
        ## indicates that the given values are organized as a list.
        "list"
    }?,
    empty
  }
\default =
  
  ## (default feature value) represents the value part of a feature-value specification which contains a defaulted value. [19.9. Default Values]
  element default { empty, att.global.attributes, empty }
vAlt =
  
  ## (value alternation) represents the value part of a feature-value specification which contains a set of values, only one of which can be valid. [19.8.1. Alternation]
  element vAlt {
    (model.featureVal, model.featureVal+), att.global.attributes, empty
  }
vNot =
  
  ## (value negation) represents a feature value which is the negation of its content. [19.8.2. Negation]
  element vNot { model.featureVal, att.global.attributes, empty }
vMerge =
  [
    a:documentation [
      "(merged collection of values) represents a feature value which is the result of merging together the feature values contained by its children, using the organization specified by the "
      ns1:code [ "@org" ]
      " attribute. [19.8.3. Collection of Values]"
    ]
  ]
  element vMerge {
    model.featureVal+,
    att.global.attributes,
    
    ## indicates the organization of the resulting merged values as set, bag or list.
    attribute org {
      
      ## indicates that the resulting values are organized as a set.
      "set"
      | 
        ## indicates that the resulting values are organized as a bag (multiset).
        "bag"
      | 
        ## indicates that the resulting values are organized as a list.
        "list"
    }?,
    empty
  }
fLib =
  [
    a:documentation [
      "(feature library) assembles a library of "
      ns1:code [ "<f>" ]
      " (feature) elements. [19.4. Feature Libraries and Feature-Value Libraries]"
    ]
  ]
  element fLib {
    (f+)
    >> sch:ns [ prefix = "tei" uri = "http://www.tei-c.org/ns/1.0" ],
    att.global.attributes,
    att.cmc.attributes,
    empty
  }
fvLib =
  
  ## (feature-value library) assembles a library of reusable feature value elements (including complete feature structures). [19.4. Feature Libraries and Feature-Value Libraries]
  element fvLib {
    model.featureVal*, att.global.attributes, att.cmc.attributes, empty
  }
start = fs | fvLib | fLib
sch:ns [ prefix = "tei" uri = "http://www.tei-c.org/ns/1.0" ]
sch:ns [ prefix = "xs" uri = "http://www.w3.org/2001/XMLSchema" ]
sch:ns [ prefix = "rng" uri = "http://relaxng.org/ns/structure/1.0" ]
sch:ns [
  prefix = "rna"
  uri = "http://relaxng.org/ns/compatibility/annotations/1.0"
]
sch:ns [ prefix = "sch" uri = "http://purl.oclc.org/dsdl/schematron" ]
sch:ns [ prefix = "sch1x" uri = "http://www.ascc.net/xml/schematron" ]
